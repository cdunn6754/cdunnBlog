PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE IF NOT EXISTS "django_migrations" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "app" varchar(255) NOT NULL, "name" varchar(255) NOT NULL, "applied" datetime NOT NULL);
INSERT INTO django_migrations VALUES(1,'contenttypes','0001_initial','2018-07-03 01:01:31.393230');
INSERT INTO django_migrations VALUES(2,'auth','0001_initial','2018-07-03 01:01:31.672655');
INSERT INTO django_migrations VALUES(3,'admin','0001_initial','2018-07-03 01:01:31.918791');
INSERT INTO django_migrations VALUES(4,'admin','0002_logentry_remove_auto_add','2018-07-03 01:01:32.175772');
INSERT INTO django_migrations VALUES(5,'contenttypes','0002_remove_content_type_name','2018-07-03 01:01:32.423684');
INSERT INTO django_migrations VALUES(6,'auth','0002_alter_permission_name_max_length','2018-07-03 01:01:32.668304');
INSERT INTO django_migrations VALUES(7,'auth','0003_alter_user_email_max_length','2018-07-03 01:01:32.923843');
INSERT INTO django_migrations VALUES(8,'auth','0004_alter_user_username_opts','2018-07-03 01:01:33.157052');
INSERT INTO django_migrations VALUES(9,'auth','0005_alter_user_last_login_null','2018-07-03 01:01:33.379530');
INSERT INTO django_migrations VALUES(10,'auth','0006_require_contenttypes_0002','2018-07-03 01:01:33.478458');
INSERT INTO django_migrations VALUES(11,'auth','0007_alter_validators_add_error_messages','2018-07-03 01:01:33.701600');
INSERT INTO django_migrations VALUES(12,'auth','0008_alter_user_username_max_length','2018-07-03 01:01:33.935024');
INSERT INTO django_migrations VALUES(13,'auth','0009_alter_user_last_name_max_length','2018-07-03 01:01:34.168223');
INSERT INTO django_migrations VALUES(14,'blogUser','0001_initial','2018-07-03 01:01:34.401519');
INSERT INTO django_migrations VALUES(15,'blogPost','0001_initial','2018-07-03 01:01:34.712434');
INSERT INTO django_migrations VALUES(16,'content','0001_initial','2018-07-03 01:01:34.957702');
INSERT INTO django_migrations VALUES(17,'sessions','0001_initial','2018-07-03 01:01:35.194499');
CREATE TABLE IF NOT EXISTS "auth_group" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(80) NOT NULL UNIQUE);
CREATE TABLE IF NOT EXISTS "auth_group_permissions" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "group_id" integer NOT NULL REFERENCES "auth_group" ("id") DEFERRABLE INITIALLY DEFERRED, "permission_id" integer NOT NULL REFERENCES "auth_permission" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE TABLE IF NOT EXISTS "auth_user_groups" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "user_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED, "group_id" integer NOT NULL REFERENCES "auth_group" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE TABLE IF NOT EXISTS "auth_user_user_permissions" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "user_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED, "permission_id" integer NOT NULL REFERENCES "auth_permission" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE TABLE IF NOT EXISTS "django_admin_log" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "object_id" text NULL, "object_repr" varchar(200) NOT NULL, "action_flag" smallint unsigned NOT NULL, "change_message" text NOT NULL, "content_type_id" integer NULL REFERENCES "django_content_type" ("id") DEFERRABLE INITIALLY DEFERRED, "user_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED, "action_time" datetime NOT NULL);
INSERT INTO django_admin_log VALUES(1,'1',' ',1,'[{"added": {}}]',7,1,'2018-07-04 15:28:25.825258');
INSERT INTO django_admin_log VALUES(2,'1','ContentTopic: C++',1,'[{"added": {}}]',11,1,'2018-07-04 15:31:31.574989');
INSERT INTO django_admin_log VALUES(3,'2','ContentTopic: OpenFOAM',1,'[{"added": {}}]',11,1,'2018-07-04 15:31:39.145179');
INSERT INTO django_admin_log VALUES(4,'3','ContentTopic: Python 3',1,'[{"added": {}}]',11,1,'2018-07-04 15:31:45.486263');
INSERT INTO django_admin_log VALUES(5,'1','ContentPost: Multiphase Density Treatment in OpenFOAM 5.x',1,'[{"added": {}}]',10,1,'2018-07-04 15:33:32.922407');
CREATE TABLE IF NOT EXISTS "django_content_type" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "app_label" varchar(100) NOT NULL, "model" varchar(100) NOT NULL);
INSERT INTO django_content_type VALUES(1,'admin','logentry');
INSERT INTO django_content_type VALUES(2,'auth','permission');
INSERT INTO django_content_type VALUES(3,'auth','group');
INSERT INTO django_content_type VALUES(4,'auth','user');
INSERT INTO django_content_type VALUES(5,'contenttypes','contenttype');
INSERT INTO django_content_type VALUES(6,'sessions','session');
INSERT INTO django_content_type VALUES(7,'blogUser','bloguser');
INSERT INTO django_content_type VALUES(8,'blogPost','blogcomment');
INSERT INTO django_content_type VALUES(9,'blogPost','blogpost');
INSERT INTO django_content_type VALUES(10,'content','contentpost');
INSERT INTO django_content_type VALUES(11,'content','contenttopic');
CREATE TABLE IF NOT EXISTS "auth_permission" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "content_type_id" integer NOT NULL REFERENCES "django_content_type" ("id") DEFERRABLE INITIALLY DEFERRED, "codename" varchar(100) NOT NULL, "name" varchar(255) NOT NULL);
INSERT INTO auth_permission VALUES(1,1,'add_logentry','Can add log entry');
INSERT INTO auth_permission VALUES(2,1,'change_logentry','Can change log entry');
INSERT INTO auth_permission VALUES(3,1,'delete_logentry','Can delete log entry');
INSERT INTO auth_permission VALUES(4,2,'add_permission','Can add permission');
INSERT INTO auth_permission VALUES(5,2,'change_permission','Can change permission');
INSERT INTO auth_permission VALUES(6,2,'delete_permission','Can delete permission');
INSERT INTO auth_permission VALUES(7,3,'add_group','Can add group');
INSERT INTO auth_permission VALUES(8,3,'change_group','Can change group');
INSERT INTO auth_permission VALUES(9,3,'delete_group','Can delete group');
INSERT INTO auth_permission VALUES(10,4,'add_user','Can add user');
INSERT INTO auth_permission VALUES(11,4,'change_user','Can change user');
INSERT INTO auth_permission VALUES(12,4,'delete_user','Can delete user');
INSERT INTO auth_permission VALUES(13,5,'add_contenttype','Can add content type');
INSERT INTO auth_permission VALUES(14,5,'change_contenttype','Can change content type');
INSERT INTO auth_permission VALUES(15,5,'delete_contenttype','Can delete content type');
INSERT INTO auth_permission VALUES(16,6,'add_session','Can add session');
INSERT INTO auth_permission VALUES(17,6,'change_session','Can change session');
INSERT INTO auth_permission VALUES(18,6,'delete_session','Can delete session');
INSERT INTO auth_permission VALUES(19,7,'add_bloguser','Can add blog user');
INSERT INTO auth_permission VALUES(20,7,'change_bloguser','Can change blog user');
INSERT INTO auth_permission VALUES(21,7,'delete_bloguser','Can delete blog user');
INSERT INTO auth_permission VALUES(22,8,'add_blogcomment','Can add blog comment');
INSERT INTO auth_permission VALUES(23,8,'change_blogcomment','Can change blog comment');
INSERT INTO auth_permission VALUES(24,8,'delete_blogcomment','Can delete blog comment');
INSERT INTO auth_permission VALUES(25,9,'add_blogpost','Can add blog post');
INSERT INTO auth_permission VALUES(26,9,'change_blogpost','Can change blog post');
INSERT INTO auth_permission VALUES(27,9,'delete_blogpost','Can delete blog post');
INSERT INTO auth_permission VALUES(28,10,'add_contentpost','Can add content post');
INSERT INTO auth_permission VALUES(29,10,'change_contentpost','Can change content post');
INSERT INTO auth_permission VALUES(30,10,'delete_contentpost','Can delete content post');
INSERT INTO auth_permission VALUES(31,11,'add_contenttopic','Can add content topic');
INSERT INTO auth_permission VALUES(32,11,'change_contenttopic','Can change content topic');
INSERT INTO auth_permission VALUES(33,11,'delete_contenttopic','Can delete content topic');
CREATE TABLE IF NOT EXISTS "auth_user" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "password" varchar(128) NOT NULL, "last_login" datetime NULL, "is_superuser" bool NOT NULL, "username" varchar(150) NOT NULL UNIQUE, "first_name" varchar(30) NOT NULL, "email" varchar(254) NOT NULL, "is_staff" bool NOT NULL, "is_active" bool NOT NULL, "date_joined" datetime NOT NULL, "last_name" varchar(150) NOT NULL);
INSERT INTO auth_user VALUES(1,'pbkdf2_sha256$100000$JUVK1y5MiaF3$X1wAs6DIUgt4xdiIemywzKl2hUYSAVflGwEpcJv+ZdI=','2018-07-04 15:28:05.845219',1,'clint','','asdf@gmail.com',1,1,'2018-07-04 15:27:33.827191','');
CREATE TABLE IF NOT EXISTS "blogUser_bloguser" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "blogPoster" bool NOT NULL, "commentPoster" bool NOT NULL, "user_id" integer NOT NULL UNIQUE REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
INSERT INTO blogUser_bloguser VALUES(1,1,1,1);
CREATE TABLE IF NOT EXISTS "blogPost_blogpost" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(250) NOT NULL, "user_markdown" text NOT NULL, "author_id" integer NOT NULL REFERENCES "blogUser_bloguser" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE TABLE IF NOT EXISTS "blogPost_blogcomment" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "date_created" date NOT NULL, "date_modified" date NOT NULL, "body" varchar(1000) NOT NULL, "author_id" integer NOT NULL REFERENCES "blogUser_bloguser" ("id") DEFERRABLE INITIALLY DEFERRED, "blog_post_id" integer NOT NULL REFERENCES "blogPost_blogpost" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE TABLE IF NOT EXISTS "content_contentpost" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(250) NOT NULL, "description" varchar(500) NOT NULL, "body" text NOT NULL, "image" varchar(100) NOT NULL, "creation_date" date NOT NULL, "date_modified" date NOT NULL, "slug" varchar(200) NOT NULL UNIQUE);
INSERT INTO content_contentpost VALUES(1,'Multiphase Density Treatment in OpenFOAM 5.x','When soot is modeled as a gas phase species particular care is needed in calculating the density.',replace(replace('<h2 id="overview">Overview</h2>\015\012\015\012<p>With the twoEquationSoot (tes) soot model the soot is essentially treated as a gas phase species and we use the graphite janaf data to represent it. This makes it much easier to use the devolatilization and (most of the) thermodynamic/transport machinery that is built in to OF. One significant detriment to this approach is in the calculation of the gas phase density.</p>\015\012\015\012<p>The density of the gas phase mixture (at least with the thermo classes used in coalChemistryFoam and its derivatives) is calculated as</p>\015\012\015\012<p>$$ \rho = \psi * P $$\015\012in the <code>psiThermo::rho()</code> function.</p>\015\012\015\012<p>Above, \(\psi\) is the fluid compressibility field and $P$ is the pressure field. The pressure field is calculated with the Poisson equation but $\psi$ is determined from a mass weighted average of the individual species compressibilities ($\psi_i$). This is inappropriate for our soot species because physically it is small discrete particles of soot and not individual carbon atoms floating in the gas mixture as the use of the graphite janaf chemistry data implies.</p>\015\012\015\012<p>The proper multiphase treatment is to calculate the gas density as</p>\015\012\015\012<p>$$ \rho = (1 - V_s) \cdot (\psi_{*} \cdot P) + (V_s) \cdot (\rho_{soot})$$</p>\015\012\015\012<p>Where $V_s$ is the soot volume fraction, $\psi_{*}$ is the fluid compressibility calculated as before but neglecting the contribution of the soot species. The density of coal soot is empirically known to be\015\012$2000 \left[kg/m^3\right]$.</p>\015\012\015\012<h2 id="relevantclassesandfunctionsinopenfoam">Relevant classes and functions in OpenFOAM</h2>\015\012\015\012<p>The thermo class used in coalChemistryFoam, i.e.  what the <code>thermo</code> pointer is pointed at is</p>\015\012\015\012<pre><code class="c++ language-c++">hePsiThermo&lt;psiReactionThermo,\015\012          SpecieMixture&lt;reactingMixture&lt;gasHthermoPhysics&gt;&gt;\015\012          &gt;\015\012</code></pre>\015\012\015\012<p>and gasHthermoPhysics is a typedef for another class</p>\015\012\015\012<pre><code class="c++ language-c++">sutherlandTransport&lt;species::thermo&lt;janafThermo&lt;perfectgas&lt;specie&gt;&gt;,\015\012                                  sensibleEnthalpy\015\012                                 &gt;\015\012                 &gt;\015\012</code></pre>\015\012\015\012<p>Obviously that really becomes confusing quickly but there are only a few functions that are relevant to what we are trying to accomplish.</p>\015\012\015\012<ul>\015\012<li><p><code>psiThermo::rho()</code></p>\015\012\015\012<p>Same function as mentioned above. It calculates the density <code>volScalarField</code> based on the multiplication of stored values of inherited member variables <code>psi_</code> and <code>p_</code>.</p></li>\015\012\015\012<li><p><code>multiComponentMixture::cellMixture(celli)</code></p>\015\012\015\012<p><code>multiComponentMixture</code> is inherited by the <code>reactingMixture</code> class. The function calculates the thermodynamic properties for a cell based on the current mass fractions of species in that cell.</p>\015\012\015\012<pre><code class="c++ language-c++">  mixture_ = Y_[0][celli]*speciesData_[0];\015\012\015\012for (label n=1; n&lt;Y_.size(); n++)\015\012{\015\012  mixture_ += Y_[n][celli]*speciesData_[n];\015\012}\015\012</code></pre>\015\012\015\012<p>Here <code>speciesData_</code> is a list of <code>gasHThermoPhysics</code> objects, one object entry per species. For example to find the molecular wieght of $CH_4$, if it were the second species in the list one could use <code>speciesData_.W(1)</code>. The overloaded <code>+=</code> operator is used in coordination with the species mass fractions, <code>Y_</code>, to calculate mixture quantities. Importantly to us, the compressibility $\psi$, is one of these averaged quantities. We will therefore need to modify this function to exclude soot when taking the mass wieghted average.</p></li>\015\012\015\012<li><p><code>multiComponentMixture::patchFaceMixture(patchi, facei)</code></p>\015\012\015\012<p>Same as <code>multiComponentMixture::cellMixture(celli)</code> but determines the mixture thermo properties on a boundary face, not at a cell center. Everything that we do later to modify <code>cellMixture</code> needs to be done in this function as well.</p></li>\015\012\015\012<li><p><code>hePsiThermo::calculate()</code></p>\015\012\015\012<p>This function loops over all cells and calls <code>multiComponentMixture::cellMixture(celli)</code> on each of them. Once the mixture properties are calculated for a cell it sets the main thermodynamic fields of that cell based on the mixture, these include the temperature, compressibility, dynamic viscosity and thermal diffusivity.</p>\015\012\015\012<p>It subsequently calls <code>multiComponentMixture::patchFaceMixture(celli)</code> for each boundary face to similarly calculate and set the thermodynamic properties on the boundaries.</p>\015\012\015\012<p>It is in this function that we will need to differentiate between the standard <code>cellMixture</code> and a <code>sootCellMixture</code> function, which excludes soot from the mixture, when setting the values for the <code>psi_</code> field.</p></li>\015\012</ul>\015\012\015\012<h2 id="sourcecodemodifications">Source code modifications</h2>\015\012\015\012<p>It turns out that all of the needed modifications can be performed at the level of <code>hePsiThermo</code> which is particularly convenient since that is one of the classes that can be specified at run-time in the thermophysicalProperties dictionary file. Assuming the appropriate modifications can be made and compiled in a library with a renamed class, here it is called <code>sootHePsiThermo</code>, we can just select that class in the dictionary and avoid further changes to the solver source code. Unfortunately as described below there is an additional complication that is resolved with a solver modification but at least major changes to the compile time solver models are avoided.</p>\015\012\015\012<p>The overall plan is as follows:</p>\015\012\015\012<ol>\015\012<li>Copy hePsiThermo.H and hePsiThermo.C to a user source directory and rename the files and class as <code>sootHePsiThermo</code></li>\015\012\015\012<li>Write, within the new class, a <code>sootCellMixture(celli)</code> function that excludes soot from consideration</li>\015\012\015\012<li>Modify the <code>calculate()</code> function to use the new <code>sootCellMixture(celli)</code> function when setting global field <code>psi_</code></li>\015\012\015\012<li>Add <code>sootVolume_</code> field and <code>updateSootVolume()</code> function to class</li>\015\012\015\012<li>Create a function <code>sootHePsiThermo::rho()</code> that overrides <code>psiThermo::rho()</code> and uses equation 1 to calculate the density</li>\015\012\015\012<li>Modify solver to downcast the <code>thermo</code> pointer, allowing us direct access to the functions we just wrote</li>\015\012</ol>\015\012\015\012<h4 id="1copyandrenametheclass">1. Copy and rename the class</h4>\015\012\015\012<p>Copy the class from the <code>thermophysicalModels/basic/psiThermo/</code> directory by copying hePsiThermo.H and hePsiThermo.C to a user source directory. You will also need to copy the source file in which the new type will be created in the runtime selection table. That file is named psiReactionThermos.C and is located at <code>thermophysicalModels/reactionThermo/psiReactionThermo/</code>. Then change the file names (I used ''sootHePsiThermo'') and use sed to change all ''hePsiThermo'' to ''sootHePsiThermo'' e.g.</p>\015\012\015\012<pre><code>sed -i -e ''s/hePsiThermo/sootHePsiThermo/g'' *\015\012</code></pre>\015\012\015\012<p>Be sure not to change any other names, it is easy to get carried away and accidentally change ''psiReactionThermo'' to ''sootPsiReactionThermo''for instance.</p>\015\012\015\012<p>You will also need to copy a Make directory if you want to use wmake, which I would recommend. I took it from the <code>thermophysicalModels/reactionThermo</code> directory. The only file that you will be compiling (i.e. listing in the <code>Make/files</code> file) is sootPsiThermos.C, the <code>Make/options</code> file should be okay as is but if when compiling you get an error just be sure to add whichever library/header file it complains about missing to it.</p>\015\012\015\012<h4 id="2writingsootcellmixturefunction">2. Writing sootCellMixture function</h4>\015\012\015\012<p>As mentioned above the built in version of this function, <code>multicomponentMixture::cellMixture(celli)</code>, needs to be modified to exclude the soot species from consideration. Here is the implementation of the new function</p>\015\012\015\012<pre><code class="c++ language-c++">template&lt;class BasicPsiThermo, class MixtureType&gt;\015\012typename MixtureType::thermoType\015\012Foam::sootHePsiThermo&lt;BasicPsiThermo, MixtureType&gt;::sootCellMixture\015\012(\015\012  const label celli\015\012) const\015\012{\015\012\015\012  // Get those mass fractions\015\012  const PtrList&lt;volScalarField&gt;&amp; Y_ = MixtureType::Y();\015\012\015\012  // Hope that SOOT isn''t the first specie listed\015\012  typename MixtureType::thermoType mixture =\015\012      Y_[0][celli]*MixtureType::speciesData()[0];\015\012\015\012  // The whole point is to avoid SOOT\015\012  if (Y_[0].name() != "SOOT")\015\012  {\015\012      for (label n=1; n&lt;Y_.size(); n++)\015\012      {\015\012          if (Y_[n].name() != "SOOT")\015\012          {\015\012              mixture += Y_[n][celli]*MixtureType::speciesData()[n];\015\012          }\015\012      }\015\012  }\015\012  else\015\012  {\015\012      // If SOOT was the first one then reset and loop through the rest\015\012      mixture = Y_[1][celli]*MixtureType::speciesData()[1];\015\012\015\012      for (label n=1; n&lt;Y_.size(); n++)\015\012      {\015\012          mixture += Y_[n][celli]*MixtureType::speciesData()[n];\015\012      }\015\012  }\015\012\015\012  return mixture;\015\012}\015\012</code></pre>\015\012\015\012<p>Fortunately we have the <code>MixtureType</code> template arguement here that allows us to refer to anything we need from the mixture classes so this can almost be directly copied from the main OpenFOAM implementation in the <code>multiComponentMixture</code> class.</p>\015\012\015\012<p>Without going into the details here, you will need to create another function (mine is named <code>sootPatchFaceMixture(patchi,facei)</code>) that does for the boundary faces what <code>sootCellMixture(celli)</code> does for the cell centers (exclude soot from the calculation). The necessary code changes are entirely analogous.</p>\015\012\015\012<h4 id="3modifycalculatetouseournewsootcellmixturecelli">3. Modify <code>calculate()</code> to use our new <code>sootCellMixture(celli)</code></h4>\015\012\015\012<p>Now that we can calculate important thermodynamic variables in a cell while excluding soot we need to modify this function to set the main themo member <code>volScalarField psi_</code> accordingly. Here is the modified implementation which utilized <code>sootCellMixture(celli)</code> to calculate $\psi$.</p>\015\012\015\012<pre><code class="c++ language-c++">template&lt;class BasicPsiThermo, class MixtureType&gt;\015\012void Foam::sootHePsiThermo&lt;BasicPsiThermo, MixtureType&gt;::calculate()\015\012{\015\012  const scalarField&amp; hCells = this-&gt;he_;\015\012  const scalarField&amp; pCells = this-&gt;p_;\015\012\015\012  scalarField&amp; TCells = this-&gt;T_.primitiveFieldRef();\015\012  scalarField&amp; psiCells = this-&gt;psi_.primitiveFieldRef();\015\012  scalarField&amp; muCells = this-&gt;mu_.primitiveFieldRef();\015\012  scalarField&amp; alphaCells = this-&gt;alpha_.primitiveFieldRef();\015\012\015\012  forAll(TCells, celli)\015\012  {\015\012      // Use the sootCellMixture function to exclude\015\012      // soot from the calculation\015\012      const typename MixtureType::thermoType sootMixture_ =\015\012          this-&gt;sootCellMixture(celli);\015\012\015\012      const typename MixtureType::thermoType&amp; mixture_ =\015\012          this-&gt;cellMixture(celli);\015\012\015\012      TCells[celli] = mixture_.THE\015\012      (\015\012          hCells[celli],\015\012          pCells[celli],\015\012          TCells[celli]\015\012      );\015\012\015\012      psiCells[celli] = sootMixture_.psi(pCells[celli], TCells[celli]);\015\012\015\012      muCells[celli] = mixture_.mu(pCells[celli], TCells[celli]);\015\012      alphaCells[celli] = mixture_.alphah(pCells[celli], TCells[celli]);\015\012  }\015\012\015\012  volScalarField::Boundary&amp; pBf =\015\012      this-&gt;p_.boundaryFieldRef();\015\012\015\012  volScalarField::Boundary&amp; TBf =\015\012      this-&gt;T_.boundaryFieldRef();\015\012\015\012  volScalarField::Boundary&amp; psiBf =\015\012      this-&gt;psi_.boundaryFieldRef();\015\012\015\012  volScalarField::Boundary&amp; heBf =\015\012      this-&gt;he().boundaryFieldRef();\015\012\015\012  volScalarField::Boundary&amp; muBf =\015\012      this-&gt;mu_.boundaryFieldRef();\015\012\015\012  volScalarField::Boundary&amp; alphaBf =\015\012      this-&gt;alpha_.boundaryFieldRef();\015\012\015\012  forAll(this-&gt;T_.boundaryField(), patchi)\015\012  {\015\012      fvPatchScalarField&amp; pp = pBf[patchi];\015\012      fvPatchScalarField&amp; pT = TBf[patchi];\015\012      fvPatchScalarField&amp; ppsi = psiBf[patchi];\015\012      fvPatchScalarField&amp; phe = heBf[patchi];\015\012      fvPatchScalarField&amp; pmu = muBf[patchi];\015\012      fvPatchScalarField&amp; palpha = alphaBf[patchi];\015\012\015\012      if (pT.fixesValue())\015\012      {\015\012          forAll(pT, facei)\015\012          {\015\012              const typename MixtureType::thermoType&amp; mixture_ =\015\012                  this-&gt;patchFaceMixture(patchi, facei);\015\012\015\012              const typename MixtureType::thermoType&amp; sootMixture_ =\015\012                  this-&gt;sootPatchFaceMixture(patchi, facei);\015\012\015\012              phe[facei] = mixture_.HE(pp[facei], pT[facei]);\015\012\015\012              ppsi[facei] = sootMixture_.psi(pp[facei], pT[facei]);\015\012              pmu[facei] = mixture_.mu(pp[facei], pT[facei]);\015\012              palpha[facei] = mixture_.alphah(pp[facei], pT[facei]);\015\012          }\015\012      }\015\012      else\015\012      {\015\012          forAll(pT, facei)\015\012          {\015\012              const typename MixtureType::thermoType&amp; mixture_ =\015\012                  this-&gt;patchFaceMixture(patchi, facei);\015\012\015\012              const typename MixtureType::thermoType&amp; sootMixture_ =\015\012                  this-&gt;sootPatchFaceMixture(patchi, facei);\015\012\015\012              pT[facei] = mixture_.THE(phe[facei], pp[facei], pT[facei]);\015\012\015\012              ppsi[facei] = sootMixture_.psi(pp[facei], pT[facei]);\015\012              pmu[facei] = mixture_.mu(pp[facei], pT[facei]);\015\012              palpha[facei] = mixture_.alphah(pp[facei], pT[facei]);\015\012          }\015\012      }\015\012  }\015\012}\015\012</code></pre>\015\012\015\012<h4 id="4addasootvolume_fieldandupdatesootvolumefunctiontotheclass">4. Add a <code>sootVolume_</code> field and <code>updateSootVolume()</code> function to the class</h4>\015\012\015\012<p>In order to calculate the density in accordance with equation 1 we need to determine the soot volume fraction field. Since this field is of interest in its own right another valid approach might be to create the field within the solver and then just pass it to this class to make the density calculation. Here I have made it a member of the class and just added an acess function for it.</p>\015\012\015\012<p>You can see the addition of the field on my <a href="https://github.com/cdunn6754/OpenFOAM_5.x_Libraries">github</a>, there is nothing too special about it. For convenience I also added a soot density member variable, <code>sootDensity_</code>, that is hardcoded to $2000 , [kg/m^3]$.</p>\015\012\015\012<p>The function <code>updateSootVolume()</code> is taken with only minor modifications from the ''greyMeanSolidAbsoprtionEmission'' radiation absorption/emission model. I thought it was a little complicated when I first saw it but I now think it is the best way to calculate volume fraction of a species. The basic idea is to first calculate something like the mixture specific volume</p>\015\012\015\012<p>$$\015\012\nu<em>{mix}\015\012=\015\012\sum</em>{i}^{species} Y<em>i / \rho</em>i(T,P)\015\012$$</p>\015\012\015\012<p>Where $Y<em>i$ is a species mass fraction and the species density $\rho</em>i$ is calculated with the ideal gas law for the individual species. We sum $Y<em>i / \rho</em>i$ which has units $[V<em>i / \text{unit mass},]$. Summing these yields the total volume of all gas species per unit mass ($\dot{=} , V</em>{mix} / \text{unit mass}$). Then taking $\nu<em>{soot} = Y</em>{soot} / \rho<em>{soot}$ we can calculate the volume fraction as $\nu</em>{soot} / \nu<em>{mix}$ which has units of $V</em>{soot} / V_{mix}$. It is important here to use the known density of soot (2000 $[kg/m^3]$) rather than the ideal gas law prediction based on janaf thermodynamic data.</p>\015\012\015\012<p>A problem that remains in this approach is the question of what to do with the boundary values. The density field is a <code>volScalarField</code> and it therefore needs to have boundary conditions defined and we will in turn need boundary values for the soot volume fraction to calculate it. I think it should be possible to calculate boundary face valus since the <code>p_</code>, <code>T_</code> and <code>Y</code> fields are also <code>volScalarField</code>s but for now I am going to assume zero soot volume fraction at the boundaries (the last line in the function). At any rate if you do nothing the uninitialized boundary values will cause drastic density fluctuations and crash the simulation immediatly.</p>\015\012\015\012<pre><code class="c++ language-c++">template&lt;class BasicPsiThermo, class MixtureType&gt;\015\012void Foam::sootHePsiThermo&lt;BasicPsiThermo, MixtureType&gt;::updateSootVolume()\015\012{\015\012\015\012  // Hardcoded soot density\015\012  scalar sootDensity(2000.0); // kg\m^3 from dasgupta thesis\015\012\015\012  // To be the sum overall species of [m^3_species / kg_total]\015\012  scalarField specificVolumeSum =\015\012  scalarField(this-&gt;sootVolume_.size(), 0.0);\015\012\015\012  // As we iterate we will grab the SOOT species index\015\012  label sootIdx(-1);\015\012\015\012  // Pointer to the mixture for this thermo\015\012  basicSpecieMixture&amp; mixture_ = this-&gt;composition();\015\012\015\012  forAll(this-&gt;Y(), specieI)\015\012  {\015\012      const scalarField&amp; Yi = mixture_.Y()[specieI];\015\012      const word specieName = mixture_.Y()[specieI].name();\015\012\015\012      if (specieName == "SOOT")\015\012      {\015\012          sootIdx = specieI;\015\012          specificVolumeSum += Yi/sootDensity;\015\012      }\015\012      else\015\012      {\015\012          // loop through cells for non-constant density\015\012          forAll(specificVolumeSum, celli)\015\012          {\015\012              specificVolumeSum[celli] += Yi[celli]/\015\012                  mixture_.rho(specieI, this-&gt;p_[celli], this-&gt;T_[celli]);\015\012          }\015\012      }\015\012\015\012  }// end loop through species\015\012\015\012  // now find and set the soot volume fraction as\015\012  // [V_soot/kg_total] / [V_total/kg_total]\015\012  this-&gt;sootVolume_.primitiveFieldRef() =\015\012      (this-&gt;Y()[sootIdx]/sootDensity) / (specificVolumeSum);\015\012\015\012  // Set this to 0 so that psi_* P_ is used for the boundary density field.\015\012  this-&gt;sootVolume_.boundaryFieldRef() = 0.0;\015\012}\015\012</code></pre>\015\012\015\012<h4 id="5createthesoothepsithermorhofunction">5. Create the <code>sootHePsiThermo::rho()</code> function</h4>\015\012\015\012<p>Finally we are ready to actually write a new density calculation function. All of the work is already done and we can just write out the density function as described in equation 1 using the member variables we added earlier.</p>\015\012\015\012<pre><code class="c++ language-c++">template&lt;class BasicPsiThermo, class MixtureType&gt;\015\012Foam::tmp&lt;Foam::volScalarField&gt;\015\012Foam::sootHePsiThermo&lt;BasicPsiThermo, MixtureType&gt;::rho() const\015\012{\015\012\015\012  return (1.0 - this-&gt;sootVolume_)*(this-&gt;p_*this-&gt;psi_) +\015\012      (this-&gt;sootVolume_) * this-&gt;sootDensity_;\015\012}\015\012</code></pre>\015\012\015\012<h4 id="6modifiythesolvertoallowaccesstonewclass">6. Modifiy the solver to allow access to new class</h4>\015\012\015\012<p>As mentioned above I thought this would be a good approach because the use of <code>sootHePsiThermo</code> rather than <code>hePsiThermo</code> is specified at runtime from the ''thermophysicalProperties'' dictionary. That means that no solver modifications are necessary. Unfortunately I was mistaken because the thermo class within the solver is not created directly but instantiated within the combusition class. The combustion class then passes an upcasted reference to the solver, here is the code from the coalChemistryFoam createFields.H file</p>\015\012\015\012<pre><code class="c++ language-c++">Info&lt;&lt; "Creating combustion model\n" &lt;&lt; endl;\015\012\015\012autoPtr&lt;combustionModels::psiCombustionModel&gt; combustion\015\012(\015\012  combustionModels::psiCombustionModel::New(mesh)\015\012);\015\012\015\012psiReactionThermo&amp; thermo = combustion-&gt;thermo();\015\012</code></pre>\015\012\015\012<p>Examining the thermo class in a little more detail we can see why this is possible. First here is the class again, as shown at the top of this document I have replace the specific template parameters used with more general names (those used for the template parameters in the source) for brevity.</p>\015\012\015\012<pre><code class="c++ language-c++">hePsiThermo&lt;BasicThermo,MixtureType&gt;\015\012</code></pre>\015\012\015\012<p>You can look at the documentaton of the classes and discover that while <code>hePsiThermo</code> does not directly inherit from its template parameters, <code>BasicThermo</code> and <code>MixtureType</code>, it does inherit from <code>heThermo&lt;BasicThermo,MixtureType&gt;</code>. And <code>heThermo&lt;BasicThermo,MixtureType&gt;</code> inherits from both <code>BasicThermo</code> and <code>MixtureType</code>. So in the specific case where we <code>BasicThermo</code> is <code>psiReactionThermo</code> we know that <code>hePsiThermo</code> indirectly inherits from <code>psiReactionThermo</code> and it can therefore be upcast as implied in the code snippet above. I think they actually do a <code>dynamic_cast</code> on the original thermo reference within the combustion model to upcast and then just pass that member reference variable here.</p>\015\012\015\012<p>The problem with the upcast to <code>psiReactionThermo</code> is that all of the functions we just wrote in <code>hePsiThermo</code> are now inaccessible (you can''t use a base class reference to access derived class functions when those functions they aren''t present in the base class, and even then only if they are virtual functions). So the options are to either create a new combustion model too, with only the type of the thermo reference changed. Or to just use a downcast within the solver to change the reference to <code>psiReactionThermo</code> to a reference to <code>sootHePsiThermo</code>. The second option is used here.</p>\015\012\015\012<p>Here is my new version of the createFields file for the SootCoalFoam solver in which the thermo pointer is downcast using <code>dynamic_cast</code></p>\015\012\015\012<pre><code class="c++ language-c++">autoPtr&lt;combustionModels::psiCombustionModel&gt; combustion\015\012(\015\012  combustionModels::psiCombustionModel::New(mesh)\015\012);\015\012\015\012psiReactionThermo&amp; baseThermo = combustion-&gt;thermo();\015\012\015\012\015\012// Downcast baseThermo to thermo\015\012// changes type from psiReactionThermo to sootHePsiThermo\015\012// which enables us to use the functions in sootHePsiThermo\015\012sootHePsiThermo&lt;\015\012  psiReactionThermo,\015\012  SpecieMixture&lt; reactingMixture&lt; gasHThermoPhysics &gt; &gt;\015\012  &gt; &amp;thermo =\015\012  dynamic_cast&lt;\015\012      sootHePsiThermo&lt;\015\012          psiReactionThermo,\015\012          SpecieMixture&lt;reactingMixture&lt;gasHThermoPhysics &gt; &gt;\015\012          &gt; &amp;&gt;\015\012                                      (baseThermo);\015\012</code></pre>\015\012\015\012<p>It is really messy, maybe some typdefs would be helpful to understand here but all we are doing is telling the pointer that it now points to type</p>\015\012\015\012<pre><code class="c++ language-c++">hePsiThermo&lt;psiReactionThermo,\015\012          SpecieMixture&lt;reactingMixture&lt;gasHthermoPhysics&gt;&gt;\015\012          &gt;\015\012</code></pre>\015\012\015\012<p>rather than just <code>psiReactionThermo</code></p>\015\012\015\012<p>I assume that the creators of OpenFOAM wrote it that way for a reason and I''m a little afraid that having the thermo pointer like that will cause a problem but so far in my testing I have not encountered any problems.</p>\015\012\015\012<p>You will need to link to the new library we created with the <code>sootHePsiThermo</code> class before compiling the solver. You will also need to include some header files for the additional classes needed in the downcast like <code>SpecieMixture</code>, <code>gasHthermoPhysics</code> and <code>reactingMixture</code>.</p>','\015',char(13)),'\012',char(10)),'ContentPostImages/Smiling_JGyGYwc.jpg','2018-07-04','2018-07-04','Multiphase-density-treatment-openfoam');
CREATE TABLE IF NOT EXISTS "content_contenttopic" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "name" varchar(100) NOT NULL, "description" varchar(500) NOT NULL);
INSERT INTO content_contenttopic VALUES(1,'C++','Relates to the language C++');
INSERT INTO content_contenttopic VALUES(2,'OpenFOAM','The open source package for computational fluid dynamics');
INSERT INTO content_contenttopic VALUES(3,'Python 3','Involves Python 3');
CREATE TABLE IF NOT EXISTS "content_contentpost_contentTopics" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "contentpost_id" integer NOT NULL REFERENCES "content_contentpost" ("id") DEFERRABLE INITIALLY DEFERRED, "contenttopic_id" integer NOT NULL REFERENCES "content_contenttopic" ("id") DEFERRABLE INITIALLY DEFERRED);
INSERT INTO content_contentpost_contentTopics VALUES(1,1,1);
INSERT INTO content_contentpost_contentTopics VALUES(2,1,2);
CREATE TABLE IF NOT EXISTS "django_session" ("session_key" varchar(40) NOT NULL PRIMARY KEY, "session_data" text NOT NULL, "expire_date" datetime NOT NULL);
INSERT INTO django_session VALUES('wud0ihgpg0cyh0lfzq4rrleogbdkj24p','OTEyOTZiZDlhYzNjODZmOGJhNTRkZTA5NTczODY2MGNiMzExODIwMjp7Il9hdXRoX3VzZXJfaWQiOiIxIiwiX2F1dGhfdXNlcl9iYWNrZW5kIjoiZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiJjMmI3MzFiMWRlOGRlZDI0MTNlZTYzZDY0NzY0ZDQxMGE4NjFjM2RkIn0=','2018-07-18 15:28:05.977358');
DELETE FROM sqlite_sequence;
INSERT INTO sqlite_sequence VALUES('django_migrations',17);
INSERT INTO sqlite_sequence VALUES('django_admin_log',5);
INSERT INTO sqlite_sequence VALUES('django_content_type',11);
INSERT INTO sqlite_sequence VALUES('auth_permission',33);
INSERT INTO sqlite_sequence VALUES('auth_user',1);
INSERT INTO sqlite_sequence VALUES('blogPost_blogcomment',0);
INSERT INTO sqlite_sequence VALUES('blogUser_bloguser',1);
INSERT INTO sqlite_sequence VALUES('content_contenttopic',3);
INSERT INTO sqlite_sequence VALUES('content_contentpost',1);
INSERT INTO sqlite_sequence VALUES('content_contentpost_contentTopics',2);
CREATE UNIQUE INDEX auth_group_permissions_group_id_permission_id_0cd325b0_uniq ON "auth_group_permissions" ("group_id", "permission_id");
CREATE INDEX "auth_group_permissions_group_id_b120cbf9" ON "auth_group_permissions" ("group_id");
CREATE INDEX "auth_group_permissions_permission_id_84c5c92e" ON "auth_group_permissions" ("permission_id");
CREATE UNIQUE INDEX auth_user_groups_user_id_group_id_94350c0c_uniq ON "auth_user_groups" ("user_id", "group_id");
CREATE INDEX "auth_user_groups_user_id_6a12ed8b" ON "auth_user_groups" ("user_id");
CREATE INDEX "auth_user_groups_group_id_97559544" ON "auth_user_groups" ("group_id");
CREATE UNIQUE INDEX auth_user_user_permissions_user_id_permission_id_14a6b632_uniq ON "auth_user_user_permissions" ("user_id", "permission_id");
CREATE INDEX "auth_user_user_permissions_user_id_a95ead1b" ON "auth_user_user_permissions" ("user_id");
CREATE INDEX "auth_user_user_permissions_permission_id_1fbb5f2c" ON "auth_user_user_permissions" ("permission_id");
CREATE INDEX "django_admin_log_content_type_id_c4bce8eb" ON "django_admin_log" ("content_type_id");
CREATE INDEX "django_admin_log_user_id_c564eba6" ON "django_admin_log" ("user_id");
CREATE UNIQUE INDEX django_content_type_app_label_model_76bd3d3b_uniq ON "django_content_type" ("app_label", "model");
CREATE UNIQUE INDEX auth_permission_content_type_id_codename_01ab375a_uniq ON "auth_permission" ("content_type_id", "codename");
CREATE INDEX "auth_permission_content_type_id_2f476e4b" ON "auth_permission" ("content_type_id");
CREATE INDEX "blogPost_blogpost_author_id_30e45ff8" ON "blogPost_blogpost" ("author_id");
CREATE INDEX "blogPost_blogcomment_author_id_4ae2a76e" ON "blogPost_blogcomment" ("author_id");
CREATE INDEX "blogPost_blogcomment_blog_post_id_1919299d" ON "blogPost_blogcomment" ("blog_post_id");
CREATE UNIQUE INDEX content_contentpost_contentTopics_contentpost_id_contenttopic_id_0e3e706d_uniq ON "content_contentpost_contentTopics" ("contentpost_id", "contenttopic_id");
CREATE INDEX "content_contentpost_contentTopics_contentpost_id_3d3450c3" ON "content_contentpost_contentTopics" ("contentpost_id");
CREATE INDEX "content_contentpost_contentTopics_contenttopic_id_c040f3f0" ON "content_contentpost_contentTopics" ("contenttopic_id");
CREATE INDEX "django_session_expire_date_a5c62663" ON "django_session" ("expire_date");
COMMIT;
